// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createAccount = `-- name: CreateAccount :exec
INSERT INTO erp.accounts (id, user_id, title, type, default_account, verification_status, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateAccountParams struct {
	ID                 uuid.UUID       `json:"id"`
	UserID             uuid.UUID       `json:"user_id"`
	Title              string          `json:"title"`
	Type               string          `json:"type"`
	DefaultAccount     bool            `json:"default_account"`
	VerificationStatus json.RawMessage `json:"verification_status"`
	CreatedAt          time.Time       `json:"created_at"`
	UpdatedAt          time.Time       `json:"updated_at"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.ExecContext(ctx, createAccount,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Type,
		arg.DefaultAccount,
		arg.VerificationStatus,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createCatalog = `-- name: CreateCatalog :exec
INSERT INTO erp.catalogs (id, merchant_id, name, description, status, created_at, updated_at, created_by, updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateCatalogParams struct {
	ID          uuid.UUID      `json:"id"`
	MerchantID  uuid.UUID      `json:"merchant_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Status      string         `json:"status"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	CreatedBy   uuid.UUID      `json:"created_by"`
	UpdatedBy   uuid.UUID      `json:"updated_by"`
}

func (q *Queries) CreateCatalog(ctx context.Context, arg CreateCatalogParams) error {
	_, err := q.db.ExecContext(ctx, createCatalog,
		arg.ID,
		arg.MerchantID,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createCustomer = `-- name: CreateCustomer :exec
INSERT INTO erp.customers (id, customer_id, merchant_id, name, email, phone, address, loyalty_points, date_of_birth, status, created_at, updated_at, created_by, updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
`

type CreateCustomerParams struct {
	ID            uuid.UUID      `json:"id"`
	CustomerID    uuid.UUID      `json:"customer_id"`
	MerchantID    uuid.UUID      `json:"merchant_id"`
	Name          string         `json:"name"`
	Email         string         `json:"email"`
	Phone         sql.NullString `json:"phone"`
	Address       sql.NullString `json:"address"`
	LoyaltyPoints sql.NullInt32  `json:"loyalty_points"`
	DateOfBirth   sql.NullString `json:"date_of_birth"`
	Status        string         `json:"status"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
	CreatedBy     uuid.UUID      `json:"created_by"`
	UpdatedBy     uuid.UUID      `json:"updated_by"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) error {
	_, err := q.db.ExecContext(ctx, createCustomer,
		arg.ID,
		arg.CustomerID,
		arg.MerchantID,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.LoyaltyPoints,
		arg.DateOfBirth,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createOrder = `-- name: CreateOrder :exec
INSERT INTO erp.orders (id, merchant_id, customer_details, order_details, order_items, metadata, tracking, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateOrderParams struct {
	ID              uuid.UUID       `json:"id"`
	MerchantID      uuid.UUID       `json:"merchant_id"`
	CustomerDetails json.RawMessage `json:"customer_details"`
	OrderDetails    json.RawMessage `json:"order_details"`
	OrderItems      json.RawMessage `json:"order_items"`
	Metadata        json.RawMessage `json:"metadata"`
	Tracking        json.RawMessage `json:"tracking"`
	CreatedAt       time.Time       `json:"created_at"`
	UpdatedAt       time.Time       `json:"updated_at"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) error {
	_, err := q.db.ExecContext(ctx, createOrder,
		arg.ID,
		arg.MerchantID,
		arg.CustomerDetails,
		arg.OrderDetails,
		arg.OrderItems,
		arg.Metadata,
		arg.Tracking,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createPaymentMethod = `-- name: CreatePaymentMethod :exec
INSERT INTO erp.payment_methods (id, merchant_id, name, type, commission, details, is_active, created_at, updated_at, created_by, updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
`

type CreatePaymentMethodParams struct {
	ID         uuid.UUID      `json:"id"`
	MerchantID uuid.UUID      `json:"merchant_id"`
	Name       string         `json:"name"`
	Type       string         `json:"type"`
	Commission float64        `json:"commission"`
	Details    sql.NullString `json:"details"`
	IsActive   bool           `json:"is_active"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
	CreatedBy  uuid.UUID      `json:"created_by"`
	UpdatedBy  uuid.UUID      `json:"updated_by"`
}

func (q *Queries) CreatePaymentMethod(ctx context.Context, arg CreatePaymentMethodParams) error {
	_, err := q.db.ExecContext(ctx, createPaymentMethod,
		arg.ID,
		arg.MerchantID,
		arg.Name,
		arg.Type,
		arg.Commission,
		arg.Details,
		arg.IsActive,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createProduct = `-- name: CreateProduct :exec
INSERT INTO erp.products (id, merchant_id, name, description, price, currency, sku, weight, dimensions, image_url, status, created_at, updated_at, created_by, updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
`

type CreateProductParams struct {
	ID          uuid.UUID      `json:"id"`
	MerchantID  uuid.UUID      `json:"merchant_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Price       float64        `json:"price"`
	Currency    sql.NullString `json:"currency"`
	Sku         sql.NullString `json:"sku"`
	Weight      sql.NullString `json:"weight"`
	Dimensions  sql.NullString `json:"dimensions"`
	ImageUrl    sql.NullString `json:"image_url"`
	Status      string         `json:"status"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	CreatedBy   uuid.UUID      `json:"created_by"`
	UpdatedBy   uuid.UUID      `json:"updated_by"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) error {
	_, err := q.db.ExecContext(ctx, createProduct,
		arg.ID,
		arg.MerchantID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Currency,
		arg.Sku,
		arg.Weight,
		arg.Dimensions,
		arg.ImageUrl,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createWarehouse = `-- name: CreateWarehouse :exec
INSERT INTO erp.warehouses (id, merchant_id, name, location, capacity, is_active, description, status, created_at, updated_at, created_by, updated_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
`

type CreateWarehouseParams struct {
	ID          uuid.UUID      `json:"id"`
	MerchantID  uuid.UUID      `json:"merchant_id"`
	Name        string         `json:"name"`
	Location    string         `json:"location"`
	Capacity    int32          `json:"capacity"`
	IsActive    bool           `json:"is_active"`
	Description sql.NullString `json:"description"`
	Status      string         `json:"status"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	CreatedBy   uuid.UUID      `json:"created_by"`
	UpdatedBy   uuid.UUID      `json:"updated_by"`
}

func (q *Queries) CreateWarehouse(ctx context.Context, arg CreateWarehouseParams) error {
	_, err := q.db.ExecContext(ctx, createWarehouse,
		arg.ID,
		arg.MerchantID,
		arg.Name,
		arg.Location,
		arg.Capacity,
		arg.IsActive,
		arg.Description,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM erp.accounts
WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAccount, id)
	return err
}

const deleteCatalog = `-- name: DeleteCatalog :exec
DELETE FROM erp.catalogs
WHERE id = $1
`

func (q *Queries) DeleteCatalog(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteCatalog, id)
	return err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM erp.customers
WHERE id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteCustomer, id)
	return err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM erp.orders
WHERE id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteOrder, id)
	return err
}

const deletePaymentMethod = `-- name: DeletePaymentMethod :exec
DELETE FROM erp.payment_methods
WHERE id = $1
`

func (q *Queries) DeletePaymentMethod(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePaymentMethod, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM erp.products
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const deleteWarehouse = `-- name: DeleteWarehouse :exec
DELETE FROM erp.warehouses
WHERE id = $1
`

func (q *Queries) DeleteWarehouse(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteWarehouse, id)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT id, user_id, title, type, default_account, verification_status, created_at, updated_at
FROM erp.accounts
WHERE id = $1
`

func (q *Queries) GetAccount(ctx context.Context, id uuid.UUID) (ErpAccount, error) {
	row := q.db.QueryRowContext(ctx, getAccount, id)
	var i ErpAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Type,
		&i.DefaultAccount,
		&i.VerificationStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCatalog = `-- name: GetCatalog :one
SELECT id, merchant_id, name, description, status, created_at, updated_at, created_by, updated_by
FROM erp.catalogs
WHERE id = $1
`

func (q *Queries) GetCatalog(ctx context.Context, id uuid.UUID) (ErpCatalog, error) {
	row := q.db.QueryRowContext(ctx, getCatalog, id)
	var i ErpCatalog
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getCatalogs = `-- name: GetCatalogs :many
SELECT id, merchant_id, name, description, status, created_at, updated_at, created_by, updated_by
FROM erp.catalogs
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetCatalogsParams struct {
	MerchantID uuid.UUID `json:"merchant_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) GetCatalogs(ctx context.Context, arg GetCatalogsParams) ([]ErpCatalog, error) {
	rows, err := q.db.QueryContext(ctx, getCatalogs, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ErpCatalog
	for rows.Next() {
		var i ErpCatalog
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, customer_id, merchant_id, name, email, phone, address, loyalty_points, date_of_birth, status, created_at, updated_at, created_by, updated_by
FROM erp.customers
WHERE id = $1
`

func (q *Queries) GetCustomer(ctx context.Context, id uuid.UUID) (ErpCustomer, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, id)
	var i ErpCustomer
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.MerchantID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Address,
		&i.LoyaltyPoints,
		&i.DateOfBirth,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getCustomers = `-- name: GetCustomers :many
SELECT id, customer_id, merchant_id, name, email, phone, address, loyalty_points, date_of_birth, status, created_at, updated_at, created_by, updated_by
FROM erp.customers
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetCustomersParams struct {
	MerchantID uuid.UUID `json:"merchant_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) GetCustomers(ctx context.Context, arg GetCustomersParams) ([]ErpCustomer, error) {
	rows, err := q.db.QueryContext(ctx, getCustomers, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ErpCustomer
	for rows.Next() {
		var i ErpCustomer
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.MerchantID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Address,
			&i.LoyaltyPoints,
			&i.DateOfBirth,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrder = `-- name: GetOrder :one
SELECT id, merchant_id, customer_details, order_details, order_items, metadata, tracking, created_at, updated_at
FROM erp.orders
WHERE id = $1
`

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (ErpOrder, error) {
	row := q.db.QueryRowContext(ctx, getOrder, id)
	var i ErpOrder
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.CustomerDetails,
		&i.OrderDetails,
		&i.OrderItems,
		&i.Metadata,
		&i.Tracking,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrders = `-- name: GetOrders :many
SELECT id, merchant_id, customer_details, order_details, order_items, metadata, tracking, created_at, updated_at
FROM erp.orders
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetOrdersParams struct {
	MerchantID uuid.UUID `json:"merchant_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]ErpOrder, error) {
	rows, err := q.db.QueryContext(ctx, getOrders, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ErpOrder
	for rows.Next() {
		var i ErpOrder
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.CustomerDetails,
			&i.OrderDetails,
			&i.OrderItems,
			&i.Metadata,
			&i.Tracking,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentMethod = `-- name: GetPaymentMethod :one
SELECT id, merchant_id, name, type, commission, details, is_active, created_at, updated_at, created_by, updated_by
FROM erp.payment_methods
WHERE id = $1
`

func (q *Queries) GetPaymentMethod(ctx context.Context, id uuid.UUID) (ErpPaymentMethod, error) {
	row := q.db.QueryRowContext(ctx, getPaymentMethod, id)
	var i ErpPaymentMethod
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Type,
		&i.Commission,
		&i.Details,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getPaymentMethods = `-- name: GetPaymentMethods :many
SELECT id, merchant_id, name, type, commission, details, is_active, created_at, updated_at, created_by, updated_by
FROM erp.payment_methods
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetPaymentMethodsParams struct {
	MerchantID uuid.UUID `json:"merchant_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) GetPaymentMethods(ctx context.Context, arg GetPaymentMethodsParams) ([]ErpPaymentMethod, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentMethods, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ErpPaymentMethod
	for rows.Next() {
		var i ErpPaymentMethod
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Type,
			&i.Commission,
			&i.Details,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one
SELECT id, merchant_id, name, description, price, currency, sku, weight, dimensions, image_url, status, created_at, updated_at, created_by, updated_by
FROM erp.products
WHERE id = $1
`

func (q *Queries) GetProduct(ctx context.Context, id uuid.UUID) (ErpProduct, error) {
	row := q.db.QueryRowContext(ctx, getProduct, id)
	var i ErpProduct
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Currency,
		&i.Sku,
		&i.Weight,
		&i.Dimensions,
		&i.ImageUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT id, merchant_id, name, description, price, currency, sku, weight, dimensions, image_url, status, created_at, updated_at, created_by, updated_by
FROM erp.products
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetProductsParams struct {
	MerchantID uuid.UUID `json:"merchant_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]ErpProduct, error) {
	rows, err := q.db.QueryContext(ctx, getProducts, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ErpProduct
	for rows.Next() {
		var i ErpProduct
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Currency,
			&i.Sku,
			&i.Weight,
			&i.Dimensions,
			&i.ImageUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWarehouse = `-- name: GetWarehouse :one
SELECT id, merchant_id, name, location, capacity, is_active, description, status, created_at, updated_at, created_by, updated_by
FROM erp.warehouses
WHERE id = $1
`

func (q *Queries) GetWarehouse(ctx context.Context, id uuid.UUID) (ErpWarehouse, error) {
	row := q.db.QueryRowContext(ctx, getWarehouse, id)
	var i ErpWarehouse
	err := row.Scan(
		&i.ID,
		&i.MerchantID,
		&i.Name,
		&i.Location,
		&i.Capacity,
		&i.IsActive,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getWarehouses = `-- name: GetWarehouses :many
SELECT id, merchant_id, name, location, capacity, is_active, description, status, created_at, updated_at, created_by, updated_by
FROM erp.warehouses
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetWarehousesParams struct {
	MerchantID uuid.UUID `json:"merchant_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) GetWarehouses(ctx context.Context, arg GetWarehousesParams) ([]ErpWarehouse, error) {
	rows, err := q.db.QueryContext(ctx, getWarehouses, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ErpWarehouse
	for rows.Next() {
		var i ErpWarehouse
		if err := rows.Scan(
			&i.ID,
			&i.MerchantID,
			&i.Name,
			&i.Location,
			&i.Capacity,
			&i.IsActive,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :exec
UPDATE erp.accounts
SET title = $2, type = $3, default_account = $4, verification_status = $5, updated_at = $6
WHERE id = $1
`

type UpdateAccountParams struct {
	ID                 uuid.UUID       `json:"id"`
	Title              string          `json:"title"`
	Type               string          `json:"type"`
	DefaultAccount     bool            `json:"default_account"`
	VerificationStatus json.RawMessage `json:"verification_status"`
	UpdatedAt          time.Time       `json:"updated_at"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) error {
	_, err := q.db.ExecContext(ctx, updateAccount,
		arg.ID,
		arg.Title,
		arg.Type,
		arg.DefaultAccount,
		arg.VerificationStatus,
		arg.UpdatedAt,
	)
	return err
}

const updateCatalog = `-- name: UpdateCatalog :exec
UPDATE erp.catalogs
SET name = $2, description = $3, status = $4, updated_at = $5, updated_by = $6
WHERE id = $1
`

type UpdateCatalogParams struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Status      string         `json:"status"`
	UpdatedAt   time.Time      `json:"updated_at"`
	UpdatedBy   uuid.UUID      `json:"updated_by"`
}

func (q *Queries) UpdateCatalog(ctx context.Context, arg UpdateCatalogParams) error {
	_, err := q.db.ExecContext(ctx, updateCatalog,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	return err
}

const updateCustomer = `-- name: UpdateCustomer :exec
UPDATE erp.customers
SET name = $2, email = $3, phone = $4, address = $5, loyalty_points = $6, date_of_birth = $7, status = $8, updated_at = $9, updated_by = $10
WHERE id = $1
`

type UpdateCustomerParams struct {
	ID            uuid.UUID      `json:"id"`
	Name          string         `json:"name"`
	Email         string         `json:"email"`
	Phone         sql.NullString `json:"phone"`
	Address       sql.NullString `json:"address"`
	LoyaltyPoints sql.NullInt32  `json:"loyalty_points"`
	DateOfBirth   sql.NullString `json:"date_of_birth"`
	Status        string         `json:"status"`
	UpdatedAt     time.Time      `json:"updated_at"`
	UpdatedBy     uuid.UUID      `json:"updated_by"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) error {
	_, err := q.db.ExecContext(ctx, updateCustomer,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Address,
		arg.LoyaltyPoints,
		arg.DateOfBirth,
		arg.Status,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	return err
}

const updateOrder = `-- name: UpdateOrder :exec
UPDATE erp.orders
SET customer_details = $2, order_details = $3, order_items = $4, metadata = $5, tracking = $6, updated_at = $7
WHERE id = $1
`

type UpdateOrderParams struct {
	ID              uuid.UUID       `json:"id"`
	CustomerDetails json.RawMessage `json:"customer_details"`
	OrderDetails    json.RawMessage `json:"order_details"`
	OrderItems      json.RawMessage `json:"order_items"`
	Metadata        json.RawMessage `json:"metadata"`
	Tracking        json.RawMessage `json:"tracking"`
	UpdatedAt       time.Time       `json:"updated_at"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateOrder,
		arg.ID,
		arg.CustomerDetails,
		arg.OrderDetails,
		arg.OrderItems,
		arg.Metadata,
		arg.Tracking,
		arg.UpdatedAt,
	)
	return err
}

const updatePaymentMethod = `-- name: UpdatePaymentMethod :exec
UPDATE erp.payment_methods
SET name = $2, type = $3, commission = $4, details = $5, is_active = $6, updated_at = $7, updated_by = $8
WHERE id = $1
`

type UpdatePaymentMethodParams struct {
	ID         uuid.UUID      `json:"id"`
	Name       string         `json:"name"`
	Type       string         `json:"type"`
	Commission float64        `json:"commission"`
	Details    sql.NullString `json:"details"`
	IsActive   bool           `json:"is_active"`
	UpdatedAt  time.Time      `json:"updated_at"`
	UpdatedBy  uuid.UUID      `json:"updated_by"`
}

func (q *Queries) UpdatePaymentMethod(ctx context.Context, arg UpdatePaymentMethodParams) error {
	_, err := q.db.ExecContext(ctx, updatePaymentMethod,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Commission,
		arg.Details,
		arg.IsActive,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	return err
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE erp.products
SET name = $2, description = $3, price = $4, currency = $5, sku = $6, weight = $7, dimensions = $8, image_url = $9, status = $10, updated_at = $11, updated_by = $12
WHERE id = $1
`

type UpdateProductParams struct {
	ID          uuid.UUID       `json:"id"`
	Name        string          `json:"name"`
	Description sql.NullString  `json:"description"`
	Price       float64         `json:"price"`
	Currency    string          `json:"currency"`
	Sku         sql.NullString  `json:"sku"`
	Weight      sql.NullFloat64 `json:"weight"`
	Dimensions  sql.NullString  `json:"dimensions"`
	ImageUrl    sql.NullString  `json:"image_url"`
	Status      string          `json:"status"`
	UpdatedAt   time.Time       `json:"updated_at"`
	UpdatedBy   uuid.UUID       `json:"updated_by"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.ExecContext(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Currency,
		arg.Sku,
		arg.Weight,
		arg.Dimensions,
		arg.ImageUrl,
		arg.Status,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	return err
}

const updateWarehouse = `-- name: UpdateWarehouse :exec
UPDATE erp.warehouses
SET name = $2, location = $3, capacity = $4, is_active = $5, description = $6, status = $7, updated_at = $8, updated_by = $9
WHERE id = $1
`

type UpdateWarehouseParams struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Location    string         `json:"location"`
	Capacity    int32          `json:"capacity"`
	IsActive    bool           `json:"is_active"`
	Description sql.NullString `json:"description"`
	Status      string         `json:"status"`
	UpdatedAt   time.Time      `json:"updated_at"`
	UpdatedBy   uuid.UUID      `json:"updated_by"`
}

func (q *Queries) UpdateWarehouse(ctx context.Context, arg UpdateWarehouseParams) error {
	_, err := q.db.ExecContext(ctx, updateWarehouse,
		arg.ID,
		arg.Name,
		arg.Location,
		arg.Capacity,
		arg.IsActive,
		arg.Description,
		arg.Status,
		arg.UpdatedAt,
		arg.UpdatedBy,
	)
	return err
}
