// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package repository

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"github.com/sqlc-dev/pqtype"
)

const countTransactions = `-- name: CountTransactions :one
SELECT COUNT(*) FROM public.transactions
WHERE   user_id=$1
`

func (q *Queries) CountTransactions(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countTransactionsStmt, countTransactions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createHostedPayment = `-- name: CreateHostedPayment :one

INSERT INTO public.hosted_payments (
    id, user_id, merchant_id, amount, currency, description, reference, 
    supported_mediums, phone_number, success_url, failed_url, callback_url, merchant_pays_fee, accept_tip
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, user_id, merchant_id, amount, currency, description, reference, supported_mediums, phone_number, success_url, failed_url, callback_url, status, transaction_id, selected_medium, selected_phone_number, merchant_pays_fee, accept_tip, created_at, updated_at, expires_at
`

type CreateHostedPaymentParams struct {
	ID               uuid.UUID       `json:"id"`
	UserID           uuid.UUID       `json:"user_id"`
	MerchantID       uuid.UUID       `json:"merchant_id"`
	Amount           string          `json:"amount"`
	Currency         string          `json:"currency"`
	Description      sql.NullString  `json:"description"`
	Reference        string          `json:"reference"`
	SupportedMediums json.RawMessage `json:"supported_mediums"`
	PhoneNumber      sql.NullString  `json:"phone_number"`
	SuccessUrl       string          `json:"success_url"`
	FailedUrl        string          `json:"failed_url"`
	CallbackUrl      sql.NullString  `json:"callback_url"`
	MerchantPaysFee  bool            `json:"merchant_pays_fee"`
	AcceptTip        bool            `json:"accept_tip"`
}

// Hosted Payments Queries
func (q *Queries) CreateHostedPayment(ctx context.Context, arg CreateHostedPaymentParams) (HostedPayment, error) {
	row := q.queryRow(ctx, q.createHostedPaymentStmt, createHostedPayment,
		arg.ID,
		arg.UserID,
		arg.MerchantID,
		arg.Amount,
		arg.Currency,
		arg.Description,
		arg.Reference,
		arg.SupportedMediums,
		arg.PhoneNumber,
		arg.SuccessUrl,
		arg.FailedUrl,
		arg.CallbackUrl,
		arg.MerchantPaysFee,
		arg.AcceptTip,
	)
	var i HostedPayment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantID,
		&i.Amount,
		&i.Currency,
		&i.Description,
		&i.Reference,
		&i.SupportedMediums,
		&i.PhoneNumber,
		&i.SuccessUrl,
		&i.FailedUrl,
		&i.CallbackUrl,
		&i.Status,
		&i.TransactionID,
		&i.SelectedMedium,
		&i.SelectedPhoneNumber,
		&i.MerchantPaysFee,
		&i.AcceptTip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :exec

INSERT INTO public.transactions (
    id, phone_number, user_id, merchant_id, type, medium, reference, comment, verified,
    ttl, details, confirm_timestamp, reference_number, test, status,
    description, token, base_amount, has_challenge, fee_amount, admin_net,
    vat_amount, merchant_net, total_amount, customer_net, currency, callback_url,
    success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag,
    has_tip, tip_amount, tipee_phone, tip_medium, merchant_pays_fee
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,
    $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28,
    $29, $30, $31, $32, $33, $34, $35, $36, $37, $38
)
`

type CreateTransactionParams struct {
	ID                uuid.UUID             `json:"id"`
	PhoneNumber       sql.NullString        `json:"phone_number"`
	UserID            uuid.UUID             `json:"user_id"`
	MerchantID        uuid.NullUUID         `json:"merchant_id"`
	Type              string                `json:"type"`
	Medium            string                `json:"medium"`
	Reference         sql.NullString        `json:"reference"`
	Comment           sql.NullString        `json:"comment"`
	Verified          sql.NullBool          `json:"verified"`
	Ttl               sql.NullInt64         `json:"ttl"`
	Details           pqtype.NullRawMessage `json:"details"`
	ConfirmTimestamp  sql.NullTime          `json:"confirm_timestamp"`
	ReferenceNumber   sql.NullString        `json:"reference_number"`
	Test              sql.NullBool          `json:"test"`
	Status            TransactionStatus     `json:"status"`
	Description       sql.NullString        `json:"description"`
	Token             sql.NullString        `json:"token"`
	BaseAmount        decimal.Decimal       `json:"base_amount"`
	HasChallenge      sql.NullBool          `json:"has_challenge"`
	FeeAmount         decimal.NullDecimal   `json:"fee_amount"`
	AdminNet          decimal.NullDecimal   `json:"admin_net"`
	VatAmount         decimal.NullDecimal   `json:"vat_amount"`
	MerchantNet       decimal.NullDecimal   `json:"merchant_net"`
	TotalAmount       decimal.NullDecimal   `json:"total_amount"`
	CustomerNet       decimal.NullDecimal   `json:"customer_net"`
	Currency          sql.NullString        `json:"currency"`
	CallbackUrl       sql.NullString        `json:"callback_url"`
	SuccessUrl        sql.NullString        `json:"success_url"`
	FailedUrl         sql.NullString        `json:"failed_url"`
	TransactionSource NullTransactionSource `json:"transaction_source"`
	QrLinkID          uuid.NullUUID         `json:"qr_link_id"`
	HostedCheckoutID  uuid.NullUUID         `json:"hosted_checkout_id"`
	QrTag             sql.NullString        `json:"qr_tag"`
	HasTip            sql.NullBool          `json:"has_tip"`
	TipAmount         sql.NullString        `json:"tip_amount"`
	TipeePhone        sql.NullString        `json:"tipee_phone"`
	TipMedium         sql.NullString        `json:"tip_medium"`
	MerchantPaysFee   sql.NullBool          `json:"merchant_pays_fee"`
}

// Common columns for reference:
// id, phone_number, user_id, merchant_id, type, medium, reference, comment,
// reference_number, description, verified, status, test, has_challenge, ttl,
// created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net,
// vat_amount, merchant_net, total_amount, currency, details, token,
// callback_url, success_url, failed_url
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.exec(ctx, q.createTransactionStmt, createTransaction,
		arg.ID,
		arg.PhoneNumber,
		arg.UserID,
		arg.MerchantID,
		arg.Type,
		arg.Medium,
		arg.Reference,
		arg.Comment,
		arg.Verified,
		arg.Ttl,
		arg.Details,
		arg.ConfirmTimestamp,
		arg.ReferenceNumber,
		arg.Test,
		arg.Status,
		arg.Description,
		arg.Token,
		arg.BaseAmount,
		arg.HasChallenge,
		arg.FeeAmount,
		arg.AdminNet,
		arg.VatAmount,
		arg.MerchantNet,
		arg.TotalAmount,
		arg.CustomerNet,
		arg.Currency,
		arg.CallbackUrl,
		arg.SuccessUrl,
		arg.FailedUrl,
		arg.TransactionSource,
		arg.QrLinkID,
		arg.HostedCheckoutID,
		arg.QrTag,
		arg.HasTip,
		arg.TipAmount,
		arg.TipeePhone,
		arg.TipMedium,
		arg.MerchantPaysFee,
	)
	return err
}

const createTransactionWithContext = `-- name: CreateTransactionWithContext :exec
INSERT INTO public.transactions (
    id, phone_number, user_id, merchant_id, type, medium, reference, comment, verified,
    ttl, details, confirm_timestamp, reference_number, test, status,
    description, token, base_amount, has_challenge, fee_amount, admin_net,
    vat_amount, merchant_net, total_amount, currency, callback_url,
    success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag,
    has_tip, tip_amount, tipee_phone, tip_medium, merchant_pays_fee
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,
    $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28,
    $29, $30, $31, $32, $33, $34, $35, $36, $37
)
`

type CreateTransactionWithContextParams struct {
	ID                uuid.UUID             `json:"id"`
	PhoneNumber       sql.NullString        `json:"phone_number"`
	UserID            uuid.UUID             `json:"user_id"`
	MerchantID        uuid.NullUUID         `json:"merchant_id"`
	Type              string                `json:"type"`
	Medium            string                `json:"medium"`
	Reference         sql.NullString        `json:"reference"`
	Comment           sql.NullString        `json:"comment"`
	Verified          sql.NullBool          `json:"verified"`
	Ttl               sql.NullInt64         `json:"ttl"`
	Details           pqtype.NullRawMessage `json:"details"`
	ConfirmTimestamp  sql.NullTime          `json:"confirm_timestamp"`
	ReferenceNumber   sql.NullString        `json:"reference_number"`
	Test              sql.NullBool          `json:"test"`
	Status            TransactionStatus     `json:"status"`
	Description       sql.NullString        `json:"description"`
	Token             sql.NullString        `json:"token"`
	BaseAmount        decimal.Decimal       `json:"base_amount"`
	HasChallenge      sql.NullBool          `json:"has_challenge"`
	FeeAmount         decimal.NullDecimal   `json:"fee_amount"`
	AdminNet          decimal.NullDecimal   `json:"admin_net"`
	VatAmount         decimal.NullDecimal   `json:"vat_amount"`
	MerchantNet       decimal.NullDecimal   `json:"merchant_net"`
	TotalAmount       decimal.NullDecimal   `json:"total_amount"`
	Currency          sql.NullString        `json:"currency"`
	CallbackUrl       sql.NullString        `json:"callback_url"`
	SuccessUrl        sql.NullString        `json:"success_url"`
	FailedUrl         sql.NullString        `json:"failed_url"`
	TransactionSource NullTransactionSource `json:"transaction_source"`
	QrLinkID          uuid.NullUUID         `json:"qr_link_id"`
	HostedCheckoutID  uuid.NullUUID         `json:"hosted_checkout_id"`
	QrTag             sql.NullString        `json:"qr_tag"`
	HasTip            sql.NullBool          `json:"has_tip"`
	TipAmount         sql.NullString        `json:"tip_amount"`
	TipeePhone        sql.NullString        `json:"tipee_phone"`
	TipMedium         sql.NullString        `json:"tip_medium"`
	MerchantPaysFee   sql.NullBool          `json:"merchant_pays_fee"`
}

func (q *Queries) CreateTransactionWithContext(ctx context.Context, arg CreateTransactionWithContextParams) error {
	_, err := q.exec(ctx, q.createTransactionWithContextStmt, createTransactionWithContext,
		arg.ID,
		arg.PhoneNumber,
		arg.UserID,
		arg.MerchantID,
		arg.Type,
		arg.Medium,
		arg.Reference,
		arg.Comment,
		arg.Verified,
		arg.Ttl,
		arg.Details,
		arg.ConfirmTimestamp,
		arg.ReferenceNumber,
		arg.Test,
		arg.Status,
		arg.Description,
		arg.Token,
		arg.BaseAmount,
		arg.HasChallenge,
		arg.FeeAmount,
		arg.AdminNet,
		arg.VatAmount,
		arg.MerchantNet,
		arg.TotalAmount,
		arg.Currency,
		arg.CallbackUrl,
		arg.SuccessUrl,
		arg.FailedUrl,
		arg.TransactionSource,
		arg.QrLinkID,
		arg.HostedCheckoutID,
		arg.QrTag,
		arg.HasTip,
		arg.TipAmount,
		arg.TipeePhone,
		arg.TipMedium,
		arg.MerchantPaysFee,
	)
	return err
}

const getByMerchantIdAndReferenceID = `-- name: GetByMerchantIdAndReferenceID :one
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions
WHERE merchant_id = $1 AND reference = $2
LIMIT 1
`

type GetByMerchantIdAndReferenceIDParams struct {
	MerchantID uuid.NullUUID  `json:"merchant_id"`
	Reference  sql.NullString `json:"reference"`
}

func (q *Queries) GetByMerchantIdAndReferenceID(ctx context.Context, arg GetByMerchantIdAndReferenceIDParams) (Transaction, error) {
	row := q.queryRow(ctx, q.getByMerchantIdAndReferenceIDStmt, getByMerchantIdAndReferenceID, arg.MerchantID, arg.Reference)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.UserID,
		&i.MerchantID,
		&i.Type,
		&i.Medium,
		&i.Reference,
		&i.Comment,
		&i.ReferenceNumber,
		&i.Description,
		&i.Verified,
		&i.Status,
		&i.Test,
		&i.HasChallenge,
		&i.WebhookReceived,
		&i.Ttl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConfirmTimestamp,
		&i.BaseAmount,
		&i.FeeAmount,
		&i.AdminNet,
		&i.VatAmount,
		&i.MerchantNet,
		&i.CustomerNet,
		&i.TotalAmount,
		&i.Currency,
		&i.Details,
		&i.Token,
		&i.ProviderTxID,
		&i.ProviderData,
		&i.MerchantPaysFee,
		&i.CallbackUrl,
		&i.SuccessUrl,
		&i.FailedUrl,
		&i.TransactionSource,
		&i.QrLinkID,
		&i.HostedCheckoutID,
		&i.QrTag,
		&i.HasTip,
		&i.TipAmount,
		&i.TipeePhone,
		&i.TipMedium,
		&i.TipTransactionID,
		&i.TipProcessed,
	)
	return i, err
}

const getByReferenceID = `-- name: GetByReferenceID :one
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions
WHERE reference = $1
LIMIT 1
`

func (q *Queries) GetByReferenceID(ctx context.Context, reference sql.NullString) (Transaction, error) {
	row := q.queryRow(ctx, q.getByReferenceIDStmt, getByReferenceID, reference)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.UserID,
		&i.MerchantID,
		&i.Type,
		&i.Medium,
		&i.Reference,
		&i.Comment,
		&i.ReferenceNumber,
		&i.Description,
		&i.Verified,
		&i.Status,
		&i.Test,
		&i.HasChallenge,
		&i.WebhookReceived,
		&i.Ttl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConfirmTimestamp,
		&i.BaseAmount,
		&i.FeeAmount,
		&i.AdminNet,
		&i.VatAmount,
		&i.MerchantNet,
		&i.CustomerNet,
		&i.TotalAmount,
		&i.Currency,
		&i.Details,
		&i.Token,
		&i.ProviderTxID,
		&i.ProviderData,
		&i.MerchantPaysFee,
		&i.CallbackUrl,
		&i.SuccessUrl,
		&i.FailedUrl,
		&i.TransactionSource,
		&i.QrLinkID,
		&i.HostedCheckoutID,
		&i.QrTag,
		&i.HasTip,
		&i.TipAmount,
		&i.TipeePhone,
		&i.TipMedium,
		&i.TipTransactionID,
		&i.TipProcessed,
	)
	return i, err
}

const getByUserIdAndReferenceID = `-- name: GetByUserIdAndReferenceID :one
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions
WHERE user_id = $1 AND reference = $2
LIMIT 1
`

type GetByUserIdAndReferenceIDParams struct {
	UserID    uuid.UUID      `json:"user_id"`
	Reference sql.NullString `json:"reference"`
}

func (q *Queries) GetByUserIdAndReferenceID(ctx context.Context, arg GetByUserIdAndReferenceIDParams) (Transaction, error) {
	row := q.queryRow(ctx, q.getByUserIdAndReferenceIDStmt, getByUserIdAndReferenceID, arg.UserID, arg.Reference)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.UserID,
		&i.MerchantID,
		&i.Type,
		&i.Medium,
		&i.Reference,
		&i.Comment,
		&i.ReferenceNumber,
		&i.Description,
		&i.Verified,
		&i.Status,
		&i.Test,
		&i.HasChallenge,
		&i.WebhookReceived,
		&i.Ttl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConfirmTimestamp,
		&i.BaseAmount,
		&i.FeeAmount,
		&i.AdminNet,
		&i.VatAmount,
		&i.MerchantNet,
		&i.CustomerNet,
		&i.TotalAmount,
		&i.Currency,
		&i.Details,
		&i.Token,
		&i.ProviderTxID,
		&i.ProviderData,
		&i.MerchantPaysFee,
		&i.CallbackUrl,
		&i.SuccessUrl,
		&i.FailedUrl,
		&i.TransactionSource,
		&i.QrLinkID,
		&i.HostedCheckoutID,
		&i.QrTag,
		&i.HasTip,
		&i.TipAmount,
		&i.TipeePhone,
		&i.TipMedium,
		&i.TipTransactionID,
		&i.TipProcessed,
	)
	return i, err
}

const getExpiredHostedPayments = `-- name: GetExpiredHostedPayments :many
SELECT id, user_id, merchant_id, amount, currency, description, reference, supported_mediums, phone_number, success_url, failed_url, callback_url, status, transaction_id, selected_medium, selected_phone_number, merchant_pays_fee, accept_tip, created_at, updated_at, expires_at FROM public.hosted_payments 
WHERE status = 'PENDING' AND expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) GetExpiredHostedPayments(ctx context.Context) ([]HostedPayment, error) {
	rows, err := q.query(ctx, q.getExpiredHostedPaymentsStmt, getExpiredHostedPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HostedPayment{}
	for rows.Next() {
		var i HostedPayment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MerchantID,
			&i.Amount,
			&i.Currency,
			&i.Description,
			&i.Reference,
			&i.SupportedMediums,
			&i.PhoneNumber,
			&i.SuccessUrl,
			&i.FailedUrl,
			&i.CallbackUrl,
			&i.Status,
			&i.TransactionID,
			&i.SelectedMedium,
			&i.SelectedPhoneNumber,
			&i.MerchantPaysFee,
			&i.AcceptTip,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilteredMerchantTransactions = `-- name: GetFilteredMerchantTransactions :many
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions
WHERE merchant_id = $1
    AND created_at BETWEEN $2 AND $3
    AND (status = $4)
    AND (type = $5)
ORDER BY created_at DESC
LIMIT $6 OFFSET $7
`

type GetFilteredMerchantTransactionsParams struct {
	MerchantID  uuid.NullUUID     `json:"merchant_id"`
	CreatedAt   time.Time         `json:"created_at"`
	CreatedAt_2 time.Time         `json:"created_at_2"`
	Status      TransactionStatus `json:"status"`
	Type        string            `json:"type"`
	Limit       int32             `json:"limit"`
	Offset      int32             `json:"offset"`
}

func (q *Queries) GetFilteredMerchantTransactions(ctx context.Context, arg GetFilteredMerchantTransactionsParams) ([]Transaction, error) {
	rows, err := q.query(ctx, q.getFilteredMerchantTransactionsStmt, getFilteredMerchantTransactions,
		arg.MerchantID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Status,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.UserID,
			&i.MerchantID,
			&i.Type,
			&i.Medium,
			&i.Reference,
			&i.Comment,
			&i.ReferenceNumber,
			&i.Description,
			&i.Verified,
			&i.Status,
			&i.Test,
			&i.HasChallenge,
			&i.WebhookReceived,
			&i.Ttl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ConfirmTimestamp,
			&i.BaseAmount,
			&i.FeeAmount,
			&i.AdminNet,
			&i.VatAmount,
			&i.MerchantNet,
			&i.CustomerNet,
			&i.TotalAmount,
			&i.Currency,
			&i.Details,
			&i.Token,
			&i.ProviderTxID,
			&i.ProviderData,
			&i.MerchantPaysFee,
			&i.CallbackUrl,
			&i.SuccessUrl,
			&i.FailedUrl,
			&i.TransactionSource,
			&i.QrLinkID,
			&i.HostedCheckoutID,
			&i.QrTag,
			&i.HasTip,
			&i.TipAmount,
			&i.TipeePhone,
			&i.TipMedium,
			&i.TipTransactionID,
			&i.TipProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilteredTransactions = `-- name: GetFilteredTransactions :many
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions
WHERE user_id = $1
    AND created_at BETWEEN $2 AND $3
    AND (status = $4)
    AND (type = $5)
ORDER BY created_at DESC
LIMIT $6 OFFSET $7
`

type GetFilteredTransactionsParams struct {
	UserID      uuid.UUID         `json:"user_id"`
	CreatedAt   time.Time         `json:"created_at"`
	CreatedAt_2 time.Time         `json:"created_at_2"`
	Status      TransactionStatus `json:"status"`
	Type        string            `json:"type"`
	Limit       int32             `json:"limit"`
	Offset      int32             `json:"offset"`
}

func (q *Queries) GetFilteredTransactions(ctx context.Context, arg GetFilteredTransactionsParams) ([]Transaction, error) {
	rows, err := q.query(ctx, q.getFilteredTransactionsStmt, getFilteredTransactions,
		arg.UserID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Status,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.UserID,
			&i.MerchantID,
			&i.Type,
			&i.Medium,
			&i.Reference,
			&i.Comment,
			&i.ReferenceNumber,
			&i.Description,
			&i.Verified,
			&i.Status,
			&i.Test,
			&i.HasChallenge,
			&i.WebhookReceived,
			&i.Ttl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ConfirmTimestamp,
			&i.BaseAmount,
			&i.FeeAmount,
			&i.AdminNet,
			&i.VatAmount,
			&i.MerchantNet,
			&i.CustomerNet,
			&i.TotalAmount,
			&i.Currency,
			&i.Details,
			&i.Token,
			&i.ProviderTxID,
			&i.ProviderData,
			&i.MerchantPaysFee,
			&i.CallbackUrl,
			&i.SuccessUrl,
			&i.FailedUrl,
			&i.TransactionSource,
			&i.QrLinkID,
			&i.HostedCheckoutID,
			&i.QrTag,
			&i.HasTip,
			&i.TipAmount,
			&i.TipeePhone,
			&i.TipMedium,
			&i.TipTransactionID,
			&i.TipProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHostedPayment = `-- name: GetHostedPayment :one
SELECT id, user_id, merchant_id, amount, currency, description, reference, supported_mediums, phone_number, success_url, failed_url, callback_url, status, transaction_id, selected_medium, selected_phone_number, merchant_pays_fee, accept_tip, created_at, updated_at, expires_at FROM public.hosted_payments 
WHERE id = $1
`

func (q *Queries) GetHostedPayment(ctx context.Context, id uuid.UUID) (HostedPayment, error) {
	row := q.queryRow(ctx, q.getHostedPaymentStmt, getHostedPayment, id)
	var i HostedPayment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantID,
		&i.Amount,
		&i.Currency,
		&i.Description,
		&i.Reference,
		&i.SupportedMediums,
		&i.PhoneNumber,
		&i.SuccessUrl,
		&i.FailedUrl,
		&i.CallbackUrl,
		&i.Status,
		&i.TransactionID,
		&i.SelectedMedium,
		&i.SelectedPhoneNumber,
		&i.MerchantPaysFee,
		&i.AcceptTip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getHostedPaymentByReference = `-- name: GetHostedPaymentByReference :one
SELECT id, user_id, merchant_id, amount, currency, description, reference, supported_mediums, phone_number, success_url, failed_url, callback_url, status, transaction_id, selected_medium, selected_phone_number, merchant_pays_fee, accept_tip, created_at, updated_at, expires_at FROM public.hosted_payments 
WHERE reference = $1 AND merchant_id = $2
`

type GetHostedPaymentByReferenceParams struct {
	Reference  string    `json:"reference"`
	MerchantID uuid.UUID `json:"merchant_id"`
}

func (q *Queries) GetHostedPaymentByReference(ctx context.Context, arg GetHostedPaymentByReferenceParams) (HostedPayment, error) {
	row := q.queryRow(ctx, q.getHostedPaymentByReferenceStmt, getHostedPaymentByReference, arg.Reference, arg.MerchantID)
	var i HostedPayment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MerchantID,
		&i.Amount,
		&i.Currency,
		&i.Description,
		&i.Reference,
		&i.SupportedMediums,
		&i.PhoneNumber,
		&i.SuccessUrl,
		&i.FailedUrl,
		&i.CallbackUrl,
		&i.Status,
		&i.TransactionID,
		&i.SelectedMedium,
		&i.SelectedPhoneNumber,
		&i.MerchantPaysFee,
		&i.AcceptTip,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getMerchantTransactions = `-- name: GetMerchantTransactions :many
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetMerchantTransactionsParams struct {
	MerchantID uuid.NullUUID `json:"merchant_id"`
	Limit      int32         `json:"limit"`
	Offset     int32         `json:"offset"`
}

func (q *Queries) GetMerchantTransactions(ctx context.Context, arg GetMerchantTransactionsParams) ([]Transaction, error) {
	rows, err := q.query(ctx, q.getMerchantTransactionsStmt, getMerchantTransactions, arg.MerchantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.UserID,
			&i.MerchantID,
			&i.Type,
			&i.Medium,
			&i.Reference,
			&i.Comment,
			&i.ReferenceNumber,
			&i.Description,
			&i.Verified,
			&i.Status,
			&i.Test,
			&i.HasChallenge,
			&i.WebhookReceived,
			&i.Ttl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ConfirmTimestamp,
			&i.BaseAmount,
			&i.FeeAmount,
			&i.AdminNet,
			&i.VatAmount,
			&i.MerchantNet,
			&i.CustomerNet,
			&i.TotalAmount,
			&i.Currency,
			&i.Details,
			&i.Token,
			&i.ProviderTxID,
			&i.ProviderData,
			&i.MerchantPaysFee,
			&i.CallbackUrl,
			&i.SuccessUrl,
			&i.FailedUrl,
			&i.TransactionSource,
			&i.QrLinkID,
			&i.HostedCheckoutID,
			&i.QrTag,
			&i.HasTip,
			&i.TipAmount,
			&i.TipeePhone,
			&i.TipMedium,
			&i.TipTransactionID,
			&i.TipProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions 
WHERE id = $1
`

func (q *Queries) GetTransaction(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.queryRow(ctx, q.getTransactionStmt, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.UserID,
		&i.MerchantID,
		&i.Type,
		&i.Medium,
		&i.Reference,
		&i.Comment,
		&i.ReferenceNumber,
		&i.Description,
		&i.Verified,
		&i.Status,
		&i.Test,
		&i.HasChallenge,
		&i.WebhookReceived,
		&i.Ttl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConfirmTimestamp,
		&i.BaseAmount,
		&i.FeeAmount,
		&i.AdminNet,
		&i.VatAmount,
		&i.MerchantNet,
		&i.CustomerNet,
		&i.TotalAmount,
		&i.Currency,
		&i.Details,
		&i.Token,
		&i.ProviderTxID,
		&i.ProviderData,
		&i.MerchantPaysFee,
		&i.CallbackUrl,
		&i.SuccessUrl,
		&i.FailedUrl,
		&i.TransactionSource,
		&i.QrLinkID,
		&i.HostedCheckoutID,
		&i.QrTag,
		&i.HasTip,
		&i.TipAmount,
		&i.TipeePhone,
		&i.TipMedium,
		&i.TipTransactionID,
		&i.TipProcessed,
	)
	return i, err
}

const getTransactionWithMerchant = `-- name: GetTransactionWithMerchant :one
SELECT 
    t.id, t.phone_number, t.user_id, t.merchant_id, t.type, t.medium, t.reference, t.comment, t.reference_number, t.description, t.verified, t.status, t.test, t.has_challenge, t.webhook_received, t.ttl, t.created_at, t.updated_at, t.confirm_timestamp, t.base_amount, t.fee_amount, t.admin_net, t.vat_amount, t.merchant_net, t.customer_net, t.total_amount, t.currency, t.details, t.token, t.provider_tx_id, t.provider_data, t.merchant_pays_fee, t.callback_url, t.success_url, t.failed_url, t.transaction_source, t.qr_link_id, t.hosted_checkout_id, t.qr_tag, t.has_tip, t.tip_amount, t.tipee_phone, t.tip_medium, t.tip_transaction_id, t.tip_processed,
    m.id as merchant_id,
    m.legal_name as merchant_legal_name,
    m.trading_name as merchant_trading_name,
    m.business_registration_number as merchant_business_registration_number,
    m.tax_identification_number as merchant_tax_identification_number,
    m.business_type as merchant_business_type,
    m.industry_category as merchant_industry_category,
    m.is_betting_company as merchant_is_betting_company,
    m.lottery_certificate_number as merchant_lottery_certificate_number,
    m.website_url as merchant_website_url,
    m.established_date as merchant_established_date,
    m.status as merchant_status,
    m.created_at as merchant_created_at,
    m.updated_at as merchant_updated_at
FROM public.transactions t
LEFT JOIN merchants.merchants m ON t.merchant_id = m.id
WHERE t.id = $1
`

type GetTransactionWithMerchantRow struct {
	ID                                 uuid.UUID             `json:"id"`
	PhoneNumber                        sql.NullString        `json:"phone_number"`
	UserID                             uuid.UUID             `json:"user_id"`
	MerchantID                         uuid.NullUUID         `json:"merchant_id"`
	Type                               string                `json:"type"`
	Medium                             string                `json:"medium"`
	Reference                          sql.NullString        `json:"reference"`
	Comment                            sql.NullString        `json:"comment"`
	ReferenceNumber                    sql.NullString        `json:"reference_number"`
	Description                        sql.NullString        `json:"description"`
	Verified                           sql.NullBool          `json:"verified"`
	Status                             TransactionStatus     `json:"status"`
	Test                               sql.NullBool          `json:"test"`
	HasChallenge                       sql.NullBool          `json:"has_challenge"`
	WebhookReceived                    sql.NullBool          `json:"webhook_received"`
	Ttl                                sql.NullInt64         `json:"ttl"`
	CreatedAt                          time.Time             `json:"created_at"`
	UpdatedAt                          time.Time             `json:"updated_at"`
	ConfirmTimestamp                   sql.NullTime          `json:"confirm_timestamp"`
	BaseAmount                         decimal.Decimal       `json:"base_amount"`
	FeeAmount                          decimal.NullDecimal   `json:"fee_amount"`
	AdminNet                           decimal.NullDecimal   `json:"admin_net"`
	VatAmount                          decimal.NullDecimal   `json:"vat_amount"`
	MerchantNet                        decimal.NullDecimal   `json:"merchant_net"`
	CustomerNet                        decimal.NullDecimal   `json:"customer_net"`
	TotalAmount                        decimal.NullDecimal   `json:"total_amount"`
	Currency                           sql.NullString        `json:"currency"`
	Details                            pqtype.NullRawMessage `json:"details"`
	Token                              sql.NullString        `json:"token"`
	ProviderTxID                       sql.NullString        `json:"provider_tx_id"`
	ProviderData                       pqtype.NullRawMessage `json:"provider_data"`
	MerchantPaysFee                    sql.NullBool          `json:"merchant_pays_fee"`
	CallbackUrl                        sql.NullString        `json:"callback_url"`
	SuccessUrl                         sql.NullString        `json:"success_url"`
	FailedUrl                          sql.NullString        `json:"failed_url"`
	TransactionSource                  NullTransactionSource `json:"transaction_source"`
	QrLinkID                           uuid.NullUUID         `json:"qr_link_id"`
	HostedCheckoutID                   uuid.NullUUID         `json:"hosted_checkout_id"`
	QrTag                              sql.NullString        `json:"qr_tag"`
	HasTip                             sql.NullBool          `json:"has_tip"`
	TipAmount                          sql.NullString        `json:"tip_amount"`
	TipeePhone                         sql.NullString        `json:"tipee_phone"`
	TipMedium                          sql.NullString        `json:"tip_medium"`
	TipTransactionID                   uuid.NullUUID         `json:"tip_transaction_id"`
	TipProcessed                       sql.NullBool          `json:"tip_processed"`
	MerchantID_2                       uuid.NullUUID         `json:"merchant_id_2"`
	MerchantLegalName                  sql.NullString        `json:"merchant_legal_name"`
	MerchantTradingName                sql.NullString        `json:"merchant_trading_name"`
	MerchantBusinessRegistrationNumber sql.NullString        `json:"merchant_business_registration_number"`
	MerchantTaxIdentificationNumber    sql.NullString        `json:"merchant_tax_identification_number"`
	MerchantBusinessType               sql.NullString        `json:"merchant_business_type"`
	MerchantIndustryCategory           sql.NullString        `json:"merchant_industry_category"`
	MerchantIsBettingCompany           sql.NullBool          `json:"merchant_is_betting_company"`
	MerchantLotteryCertificateNumber   sql.NullString        `json:"merchant_lottery_certificate_number"`
	MerchantWebsiteUrl                 sql.NullString        `json:"merchant_website_url"`
	MerchantEstablishedDate            sql.NullTime          `json:"merchant_established_date"`
	MerchantStatus                     sql.NullString        `json:"merchant_status"`
	MerchantCreatedAt                  sql.NullTime          `json:"merchant_created_at"`
	MerchantUpdatedAt                  sql.NullTime          `json:"merchant_updated_at"`
}

func (q *Queries) GetTransactionWithMerchant(ctx context.Context, id uuid.UUID) (GetTransactionWithMerchantRow, error) {
	row := q.queryRow(ctx, q.getTransactionWithMerchantStmt, getTransactionWithMerchant, id)
	var i GetTransactionWithMerchantRow
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.UserID,
		&i.MerchantID,
		&i.Type,
		&i.Medium,
		&i.Reference,
		&i.Comment,
		&i.ReferenceNumber,
		&i.Description,
		&i.Verified,
		&i.Status,
		&i.Test,
		&i.HasChallenge,
		&i.WebhookReceived,
		&i.Ttl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ConfirmTimestamp,
		&i.BaseAmount,
		&i.FeeAmount,
		&i.AdminNet,
		&i.VatAmount,
		&i.MerchantNet,
		&i.CustomerNet,
		&i.TotalAmount,
		&i.Currency,
		&i.Details,
		&i.Token,
		&i.ProviderTxID,
		&i.ProviderData,
		&i.MerchantPaysFee,
		&i.CallbackUrl,
		&i.SuccessUrl,
		&i.FailedUrl,
		&i.TransactionSource,
		&i.QrLinkID,
		&i.HostedCheckoutID,
		&i.QrTag,
		&i.HasTip,
		&i.TipAmount,
		&i.TipeePhone,
		&i.TipMedium,
		&i.TipTransactionID,
		&i.TipProcessed,
		&i.MerchantID_2,
		&i.MerchantLegalName,
		&i.MerchantTradingName,
		&i.MerchantBusinessRegistrationNumber,
		&i.MerchantTaxIdentificationNumber,
		&i.MerchantBusinessType,
		&i.MerchantIndustryCategory,
		&i.MerchantIsBettingCompany,
		&i.MerchantLotteryCertificateNumber,
		&i.MerchantWebsiteUrl,
		&i.MerchantEstablishedDate,
		&i.MerchantStatus,
		&i.MerchantCreatedAt,
		&i.MerchantUpdatedAt,
	)
	return i, err
}

const getTransactions = `-- name: GetTransactions :many
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) GetTransactions(ctx context.Context, arg GetTransactionsParams) ([]Transaction, error) {
	rows, err := q.query(ctx, q.getTransactionsStmt, getTransactions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.UserID,
			&i.MerchantID,
			&i.Type,
			&i.Medium,
			&i.Reference,
			&i.Comment,
			&i.ReferenceNumber,
			&i.Description,
			&i.Verified,
			&i.Status,
			&i.Test,
			&i.HasChallenge,
			&i.WebhookReceived,
			&i.Ttl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ConfirmTimestamp,
			&i.BaseAmount,
			&i.FeeAmount,
			&i.AdminNet,
			&i.VatAmount,
			&i.MerchantNet,
			&i.CustomerNet,
			&i.TotalAmount,
			&i.Currency,
			&i.Details,
			&i.Token,
			&i.ProviderTxID,
			&i.ProviderData,
			&i.MerchantPaysFee,
			&i.CallbackUrl,
			&i.SuccessUrl,
			&i.FailedUrl,
			&i.TransactionSource,
			&i.QrLinkID,
			&i.HostedCheckoutID,
			&i.QrTag,
			&i.HasTip,
			&i.TipAmount,
			&i.TipeePhone,
			&i.TipMedium,
			&i.TipTransactionID,
			&i.TipProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByQRLink = `-- name: GetTransactionsByQRLink :many
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions 
WHERE qr_link_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsByQRLinkParams struct {
	QrLinkID uuid.NullUUID `json:"qr_link_id"`
	Limit    int32         `json:"limit"`
	Offset   int32         `json:"offset"`
}

func (q *Queries) GetTransactionsByQRLink(ctx context.Context, arg GetTransactionsByQRLinkParams) ([]Transaction, error) {
	rows, err := q.query(ctx, q.getTransactionsByQRLinkStmt, getTransactionsByQRLink, arg.QrLinkID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.UserID,
			&i.MerchantID,
			&i.Type,
			&i.Medium,
			&i.Reference,
			&i.Comment,
			&i.ReferenceNumber,
			&i.Description,
			&i.Verified,
			&i.Status,
			&i.Test,
			&i.HasChallenge,
			&i.WebhookReceived,
			&i.Ttl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ConfirmTimestamp,
			&i.BaseAmount,
			&i.FeeAmount,
			&i.AdminNet,
			&i.VatAmount,
			&i.MerchantNet,
			&i.CustomerNet,
			&i.TotalAmount,
			&i.Currency,
			&i.Details,
			&i.Token,
			&i.ProviderTxID,
			&i.ProviderData,
			&i.MerchantPaysFee,
			&i.CallbackUrl,
			&i.SuccessUrl,
			&i.FailedUrl,
			&i.TransactionSource,
			&i.QrLinkID,
			&i.HostedCheckoutID,
			&i.QrTag,
			&i.HasTip,
			&i.TipAmount,
			&i.TipeePhone,
			&i.TipMedium,
			&i.TipTransactionID,
			&i.TipProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByStatus = `-- name: GetTransactionsByStatus :many
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsByStatusParams struct {
	Status TransactionStatus `json:"status"`
	Limit  int32             `json:"limit"`
	Offset int32             `json:"offset"`
}

func (q *Queries) GetTransactionsByStatus(ctx context.Context, arg GetTransactionsByStatusParams) ([]Transaction, error) {
	rows, err := q.query(ctx, q.getTransactionsByStatusStmt, getTransactionsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.UserID,
			&i.MerchantID,
			&i.Type,
			&i.Medium,
			&i.Reference,
			&i.Comment,
			&i.ReferenceNumber,
			&i.Description,
			&i.Verified,
			&i.Status,
			&i.Test,
			&i.HasChallenge,
			&i.WebhookReceived,
			&i.Ttl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ConfirmTimestamp,
			&i.BaseAmount,
			&i.FeeAmount,
			&i.AdminNet,
			&i.VatAmount,
			&i.MerchantNet,
			&i.CustomerNet,
			&i.TotalAmount,
			&i.Currency,
			&i.Details,
			&i.Token,
			&i.ProviderTxID,
			&i.ProviderData,
			&i.MerchantPaysFee,
			&i.CallbackUrl,
			&i.SuccessUrl,
			&i.FailedUrl,
			&i.TransactionSource,
			&i.QrLinkID,
			&i.HostedCheckoutID,
			&i.QrTag,
			&i.HasTip,
			&i.TipAmount,
			&i.TipeePhone,
			&i.TipMedium,
			&i.TipTransactionID,
			&i.TipProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByType = `-- name: GetTransactionsByType :many
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions
WHERE type = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsByTypeParams struct {
	Type   string `json:"type"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetTransactionsByType(ctx context.Context, arg GetTransactionsByTypeParams) ([]Transaction, error) {
	rows, err := q.query(ctx, q.getTransactionsByTypeStmt, getTransactionsByType, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.UserID,
			&i.MerchantID,
			&i.Type,
			&i.Medium,
			&i.Reference,
			&i.Comment,
			&i.ReferenceNumber,
			&i.Description,
			&i.Verified,
			&i.Status,
			&i.Test,
			&i.HasChallenge,
			&i.WebhookReceived,
			&i.Ttl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ConfirmTimestamp,
			&i.BaseAmount,
			&i.FeeAmount,
			&i.AdminNet,
			&i.VatAmount,
			&i.MerchantNet,
			&i.CustomerNet,
			&i.TotalAmount,
			&i.Currency,
			&i.Details,
			&i.Token,
			&i.ProviderTxID,
			&i.ProviderData,
			&i.MerchantPaysFee,
			&i.CallbackUrl,
			&i.SuccessUrl,
			&i.FailedUrl,
			&i.TransactionSource,
			&i.QrLinkID,
			&i.HostedCheckoutID,
			&i.QrTag,
			&i.HasTip,
			&i.TipAmount,
			&i.TipeePhone,
			&i.TipMedium,
			&i.TipTransactionID,
			&i.TipProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsWithPendingTips = `-- name: GetTransactionsWithPendingTips :many
SELECT id, phone_number, user_id, merchant_id, type, medium, reference, comment, reference_number, description, verified, status, test, has_challenge, webhook_received, ttl, created_at, updated_at, confirm_timestamp, base_amount, fee_amount, admin_net, vat_amount, merchant_net, customer_net, total_amount, currency, details, token, provider_tx_id, provider_data, merchant_pays_fee, callback_url, success_url, failed_url, transaction_source, qr_link_id, hosted_checkout_id, qr_tag, has_tip, tip_amount, tipee_phone, tip_medium, tip_transaction_id, tip_processed FROM public.transactions 
WHERE has_tip = true AND tip_processed = false AND status = 'SUCCESS'
ORDER BY created_at ASC
`

func (q *Queries) GetTransactionsWithPendingTips(ctx context.Context) ([]Transaction, error) {
	rows, err := q.query(ctx, q.getTransactionsWithPendingTipsStmt, getTransactionsWithPendingTips)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.UserID,
			&i.MerchantID,
			&i.Type,
			&i.Medium,
			&i.Reference,
			&i.Comment,
			&i.ReferenceNumber,
			&i.Description,
			&i.Verified,
			&i.Status,
			&i.Test,
			&i.HasChallenge,
			&i.WebhookReceived,
			&i.Ttl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ConfirmTimestamp,
			&i.BaseAmount,
			&i.FeeAmount,
			&i.AdminNet,
			&i.VatAmount,
			&i.MerchantNet,
			&i.CustomerNet,
			&i.TotalAmount,
			&i.Currency,
			&i.Details,
			&i.Token,
			&i.ProviderTxID,
			&i.ProviderData,
			&i.MerchantPaysFee,
			&i.CallbackUrl,
			&i.SuccessUrl,
			&i.FailedUrl,
			&i.TransactionSource,
			&i.QrLinkID,
			&i.HostedCheckoutID,
			&i.QrTag,
			&i.HasTip,
			&i.TipAmount,
			&i.TipeePhone,
			&i.TipMedium,
			&i.TipTransactionID,
			&i.TipProcessed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const overrideTransactionStatus = `-- name: OverrideTransactionStatus :exec
WITH updated_transaction AS (
    UPDATE public.transactions
    SET status = $2, updated_at = NOW()
    WHERE id = $1
    RETURNING id
)
INSERT INTO public.transaction_status_overrides (
    id,
    transaction_id,
    reason,
    admin_id
)
VALUES (
    gen_random_uuid(),
    $1,
    $3,
    $4
)
`

type OverrideTransactionStatusParams struct {
	TransactionID uuid.UUID         `json:"transaction_id"`
	Status        TransactionStatus `json:"status"`
	Reason        string            `json:"reason"`
	AdminID       uuid.UUID         `json:"admin_id"`
}

func (q *Queries) OverrideTransactionStatus(ctx context.Context, arg OverrideTransactionStatusParams) error {
	_, err := q.exec(ctx, q.overrideTransactionStatusStmt, overrideTransactionStatus,
		arg.TransactionID,
		arg.Status,
		arg.Reason,
		arg.AdminID,
	)
	return err
}

const updateHostedPayment = `-- name: UpdateHostedPayment :exec
UPDATE public.hosted_payments 
SET 
    amount = $2,
    currency = $3,
    description = $4,
    supported_mediums = $5,
    phone_number = $6,
    success_url = $7,
    failed_url = $8,
    callback_url = $9,
    expires_at = $10,
    merchant_pays_fee = $11,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateHostedPaymentParams struct {
	ID               uuid.UUID       `json:"id"`
	Amount           string          `json:"amount"`
	Currency         string          `json:"currency"`
	Description      sql.NullString  `json:"description"`
	SupportedMediums json.RawMessage `json:"supported_mediums"`
	PhoneNumber      sql.NullString  `json:"phone_number"`
	SuccessUrl       string          `json:"success_url"`
	FailedUrl        string          `json:"failed_url"`
	CallbackUrl      sql.NullString  `json:"callback_url"`
	ExpiresAt        time.Time       `json:"expires_at"`
	MerchantPaysFee  bool            `json:"merchant_pays_fee"`
}

func (q *Queries) UpdateHostedPayment(ctx context.Context, arg UpdateHostedPaymentParams) error {
	_, err := q.exec(ctx, q.updateHostedPaymentStmt, updateHostedPayment,
		arg.ID,
		arg.Amount,
		arg.Currency,
		arg.Description,
		arg.SupportedMediums,
		arg.PhoneNumber,
		arg.SuccessUrl,
		arg.FailedUrl,
		arg.CallbackUrl,
		arg.ExpiresAt,
		arg.MerchantPaysFee,
	)
	return err
}

const updateHostedPaymentStatus = `-- name: UpdateHostedPaymentStatus :exec
UPDATE public.hosted_payments 
SET 
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateHostedPaymentStatusParams struct {
	ID     uuid.UUID           `json:"id"`
	Status HostedPaymentStatus `json:"status"`
}

func (q *Queries) UpdateHostedPaymentStatus(ctx context.Context, arg UpdateHostedPaymentStatusParams) error {
	_, err := q.exec(ctx, q.updateHostedPaymentStatusStmt, updateHostedPaymentStatus, arg.ID, arg.Status)
	return err
}

const updateHostedPaymentWithTransaction = `-- name: UpdateHostedPaymentWithTransaction :exec
UPDATE public.hosted_payments 
SET 
    transaction_id = $2,
    selected_medium = $3,
    selected_phone_number = $4,
    status = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateHostedPaymentWithTransactionParams struct {
	ID                  uuid.UUID           `json:"id"`
	TransactionID       uuid.NullUUID       `json:"transaction_id"`
	SelectedMedium      sql.NullString      `json:"selected_medium"`
	SelectedPhoneNumber sql.NullString      `json:"selected_phone_number"`
	Status              HostedPaymentStatus `json:"status"`
}

func (q *Queries) UpdateHostedPaymentWithTransaction(ctx context.Context, arg UpdateHostedPaymentWithTransactionParams) error {
	_, err := q.exec(ctx, q.updateHostedPaymentWithTransactionStmt, updateHostedPaymentWithTransaction,
		arg.ID,
		arg.TransactionID,
		arg.SelectedMedium,
		arg.SelectedPhoneNumber,
		arg.Status,
	)
	return err
}

const updateStatus = `-- name: UpdateStatus :exec
UPDATE public.transactions
SET status = $2, webhook_received = TRUE, updated_at = NOW()
WHERE id = $1
`

type UpdateStatusParams struct {
	ID     uuid.UUID         `json:"id"`
	Status TransactionStatus `json:"status"`
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) error {
	_, err := q.exec(ctx, q.updateStatusStmt, updateStatus, arg.ID, arg.Status)
	return err
}

const updateTipProcessing = `-- name: UpdateTipProcessing :exec
UPDATE public.transactions 
SET 
    tip_transaction_id = $2,
    tip_processed = true,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateTipProcessingParams struct {
	ID               uuid.UUID     `json:"id"`
	TipTransactionID uuid.NullUUID `json:"tip_transaction_id"`
}

func (q *Queries) UpdateTipProcessing(ctx context.Context, arg UpdateTipProcessingParams) error {
	_, err := q.exec(ctx, q.updateTipProcessingStmt, updateTipProcessing, arg.ID, arg.TipTransactionID)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :exec
UPDATE public.transactions 
SET 
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateTransactionParams struct {
	ID     uuid.UUID         `json:"id"`
	Status TransactionStatus `json:"status"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) error {
	_, err := q.exec(ctx, q.updateTransactionStmt, updateTransaction, arg.ID, arg.Status)
	return err
}
